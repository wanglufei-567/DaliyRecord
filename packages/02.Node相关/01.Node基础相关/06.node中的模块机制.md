#### 模块加载机制

简单来说，模块加载机制也就是 `require` 函数执行的主要流程，在 `Node.js` 中模块加载一般会经历三个步骤，『路径分析』、『文件定位』、『编译执行』，按照模块的分类，按照以下顺序进行优先加载

- 系统缓存，模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值

- 系统模块，也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了『路径分析』、『文件定位』，直接加载到了内存中，系统模块定义在 `Node.js` 源码的 `lib` 目录下

- 文件模块，优先加载以 `.`、`..` 、`/` 开头的，如果文件没有加上扩展名，会依次按照 `.js`、`.json`、`.node`

    进行扩展名补足尝试，那么在尝试的过程中也是以同步阻塞模式来判断文件是否存在

  - 从性能优化的角度来看待，`.json`、`.node` 最好还是加上文件的扩展名

- 目录做为模块，这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个『包』来处理

  - `Node.js` 这块采用了 `Commonjs` 规范，先会在项目根目录查找 `package.json` 文件，取出文件中定义的 `main` 属性 `("main": "lib/hello.js")` 描述的入口文件进行加载
  - 如果也没加载到，则会抛出默认错误: `Error: Cannot find module 'lib/hello.js'`

- `node_modules` 目录加载，对于系统模块、路径文件模块都找不到，`Node.js` 会从当前模块的父目录进行查找，直到系统的根目录



#### 模块中的 module、exports、**dirname、**filename 和 require 来自何方？

在执行代码之前，`Node.js` 会对要执行的代码进行封装

```
(function(exports, require, module, __filename, __dirname) {
  // 模块的代码
})
```



#### 模块之间循环依赖是否会陷入死循环？

我们先来看看什么是循环依赖，所谓循环依赖就是，当模块 `a` 执行时需要依赖模块 `b` 中定义的属性或方法，而在导入模块 `b` 中，发现模块 `b` 同时也依赖模块 `a` 中的属性或方法，即两个模块之间互相依赖，这种现象我们称之为循环依赖，我们来验证一下

```
// a.js
exports.a = 1
exports.b = 2
require('./b')
exports.c = 3

// b.js
const a = require('./a')
console.log(a)
```

当在控制台运行 `a.js` 之后可以发现程序正常运行，并不会出现死循环，但『只会输出相应模块已加载的部分数据』，如下

```
{ a: 1, b: 2 }
```

所以我们可以得出结论，在启动 `a.js` 的时候，会加载 `b.js`，那么在 `b.js` 中又加载了 `a.js`，但是此时 `a.js` 模块还没有执行完，返回的是一个 `a.js` 模块的 `exports` 对象『未完成的副本』给到 `b.js` 模块（因此是不会陷入死循环的），然后 `b.js` 完成加载之后将 `exports` 对象提供给了 `a.js` 模块



#### 